---
title: "CPU Performance Anaylsis"
author: "David Parsons"
date: "January 29, 2017"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
```

## Insipiration

Central Processing Units (CPUs) are central to any computing system. They perform every single operation, calculation, or any other action required to keep the "Computer" as a whole running. So it's important to understand what CPU features and architecures equate to the best performance.

## The Data

```{r cpu}

cpu <- read.csv("cpus.csv")
summary(cpu)
```

Data Collected from https://vincentarelbundock.github.io/Rdatasets/datasets.html, a repo of random datasets. This dataset had been collected as a part of a research study on extimating CPU performance.

Each CPU had the following properties:

    sysct - cycle time in nanoseconds
    mmin - minimum main memory in kilobytes
    mmax - maximum main memory in kilobytes
    cach - cache size in kilobytes
    chmin - minimum number of channels
    chmax - maximum number of channels
    perf - benchmark score

## Investigation

The following are the step by step thought process I followed in order to achive conclusions about this dataset.

### Features on Performance

I started by plotting every "feature" against performance in order to determine if one feature has a sustantial effect on improving performance.

```{r Performance Plots}
perf <- cpu$perf

cycleOnPerf <- plot(cpu$syct, perf, main="CPU Cycle Time vs. Performance", xlab = "Cycle Time in Seconds", ylab = "Benchmark Performance", xlim = rev(range(cpu$syct)), col = "blue")

memMaxOnPerf <- plot(cpu$mmax, perf, main="CPU Memory (max) vs. Performance", xlab = "Max Memory in Kilobytes", ylab = "Benchmark Performance", col = "red")

memMinOnPerf <- plot(cpu$mmin, perf, main="CPU Memory (min) vs. Performance", xlab = "Minimum Memory in Kilobytes", ylab = "Benchmark Performance", col = "red")

chanMaxOnPerf <- plot(cpu$chmax, perf, main="Channels (max) vs. Performance", xlab = "Max Channels", ylab = "Benchmark Performance", col = "darkgreen")

chanMinOnPerf <- plot(cpu$chmin, perf, main="Channels (min) vs. Performance", xlab = "Min Channels", ylab = "Benchmark Performance", col = "darkgreen")

cacheOnPerf <- plot(cpu$cach, perf,main="CPU Cache vs. Performance", xlab = "Cache in Kilobytes", ylab = "Benchmark Performance", col = "orange")

```

### Observation 1 - Cycle Time

Clear coorelation between a decrease in cycle time and an increase in performance.

But there is still something else that improve's a CPU's performance.

    - CPU's with the same minimal cycle time had drastically different benchmark scores.

```{r Cycle Time}
cycleTBox <- boxplot(cpu$syct, data = cpu, xlab = "Cycle Time in Nanoseconds",col = "lightblue", medcol = "orange", bg = "blue", range = 4, cex.main=2,cex.lab=1.5, horizontal = TRUE, varwidth = TRUE, pch = 19)

upperNinty = as.numeric(quantile(cpu$perf, 0.9))

ggplot(cpu,aes(syct, fill = (perf > upperNinty)))+geom_density()+scale_x_continuous(name = "Cycle Time in Nanoseconds")+scale_y_continuous(name = "Density")

```

### Observation 2 - Main Memory

It appears that having to little memory can create a bottleneck for a CPU's performance.

    - No CPU that had a minimum of 6000 KB of memory during the benchmark scored better than 500.
    
But an increase in memory only coorelates to an increase in performance to a certain extent.

    - Some CPU performed worse than another CPU with double the amount of minimum memory.

```{r Memory}

cycleTBox <- boxplot(cpu$mmax, data = cpu, xlab = "Memory (max) in Kilobytes",col = "lightgreen", medcol = "blue", bg = "blue", range = 4, cex.main=2,cex.lab=1.5, horizontal = TRUE, varwidth = TRUE, pch = 19)

upperNinty = as.numeric(quantile(cpu$perf, 0.9))

ggplot(cpu,aes(mmax, fill = (perf > upperNinty)))+geom_density()+geom_density()+scale_x_continuous(name = "Memory (max) in Kilobytes")+scale_y_continuous(name = "Density")

```

### Observation 3 - Cache Size

In theory more cache should equate to better performance, but

    - Some CPUs with 0 cache scored in the 90th percentile.

```{r Cache}
cacheBox <- boxplot(cpu$cach, data = cpu, xlab = "Cache in Kilobytes",col = "grey", medcol = "red", bg = "blue", range = 4, cex.main=2,cex.lab=1.5, horizontal = TRUE, varwidth = TRUE, pch = 19)

upperNinty = as.numeric(quantile(cpu$perf, 0.9))

ggplot(cpu,aes(cach, fill = (perf > upperNinty)))+geom_density()+geom_density()+scale_x_continuous(name = "Cache in Kilobytes")+scale_y_continuous(name = "Density")
```

### Conlusion & Next Steps
There isn't a particular "feature" that seemed to provide THE best performance increase.

A heat map might help to demonstrate what combination of features is the most benefical for increasing performance.

It's also very possible other factors/"features" are effecting performance architecture, tempurature, power draw, cores, etc.

Price to Performance might also be an interesting metric and how it relates to certain "features".

The fastest cycle time was 17 nanoseconds, which equates to about 58 MHz or 0.06 GHz, which is very slow compared to modern CPUs. So there may be other bottlenecks with these CPUs.

It'd be interesting to replicate this analysis on modern day consumer CPUs.
