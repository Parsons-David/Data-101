---
title: "CPU Perforance Anaylsis"
author: "David Parsons"
date: "January 29, 2017"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Insipiration

Central Processing Units (CPUs) are central to any computing system. They perform every single operation, calculation, or any other action required to keep the "Computer" as a whole running. So it's important to understand what CPU features and architecures equate to the best performance.

## The Data

```{r cpu}
cpu <- read.csv("cpus.csv")
summary(cpu)
```

Data Collected from https://vincentarelbundock.github.io/Rdatasets/datasets.html, a repo of random datasets. This dataset had been collected as a part of a research study on extimating CPU performance.

Each CPU had the following properties:

    sysct - cycle time in nanoseconds
    mmin - minimum main memory in kilobytes
    mmax - maximum main memory in kilobytes
    cach - cache size in kilobytes
    chmin - minimum number of channels
    chmax - maximum number of channels
    perf - benchmark score

## Investigation

The following is the step by step thought process I followed in order to achive conclusions about this dataset.

## Features on Performance

I started by plotting every "feature" against performance in order to determine if one feature has a sustantial effect on improving performance.

```{r Perf Plots, echo=FALSE}

perf <- cpu$perf

cycleOnPerf <- plot(cpu$syct, perf, main="CPU Cycle Time vs. Performance", xlab = "Cycle Time in Seconds", ylab = "Benchmark Performance", xlim = rev(range(cpu$syct)), col = "blue")

memMaxOnPerf <- plot(cpu$mmax, perf, main="CPU Memory (max) vs. Performance", xlab = "Max Memory in Kilobytes", ylab = "Benchmark Performance", col = "red")

memMinOnPerf <- plot(cpu$mmin, perf, main="CPU Memory (min) vs. Performance", xlab = "Minimum Memory in Kilobytes", ylab = "Benchmark Performance", col = "red")

chanMaxOnPerf <- plot(cpu$chmax, perf, main="Channels (max) vs. Performance", xlab = "Max Channels", ylab = "Benchmark Performance", col = "darkgreen")

chanMinOnPerf <- plot(cpu$chmin, perf, main="Channels (min) vs. Performance", xlab = "Min Channels", ylab = "Benchmark Performance", col = "darkgreen")

cacheOnPerf <- plot(cpu$cach, perf,main="CPU Cache vs. Performance", xlab = "Cache in Kilobytes", ylab = "Benchmark Performance", col = "orange")

```

### Observation 1 - Cycle Time

Clear coorelation between a decrease in cycle time and an increase in performance.

But there is still something else that improve's a CPU's performance.

    - CPU's with the same minimal cycle time had drastically different benchmark scores.

Here's a Distribution show

```{r cycle time bar}

cycbleTBox <- boxplot(cpu$syct, data = cpu, xlab = "Cycle Time in Nanoseconds",col = "lightblue", medcol = "orange", bg = "blue", range = 4, cex.main=2,cex.lab=1.5, horizontal = TRUE, varwidth = TRUE, pch = 19)
```

### Observation 2 - Main Memory

It appears that having to little memory can create a bottleneck for a CPU's performance.

    - No CPU's with that had a minimum of 6000 KB of memory during the benchmark scored better than 500.
    
But an increase in memory only coorelates to an increase in performance to a certain extent.

    - Some CPU's performed worse than other CPU's with double the amount of minimum memory.


In theory more cache should equate to better performance.

Below is a plot of cache Size in KB (x-axis) vs the measured performance of a CPU with that cache size (y-axis).

```{r cach plot, echo=TRUE}
cacheOnPerf <- plot(cpu$cach, cpu$perf, main = "CPU Cache vs. Performance", xlab = "Cache in Kilobytes", ylab = "Benchmark Performance", pch = 19)
```
